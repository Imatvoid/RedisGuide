# Scan





## keys  pattern的缺点

```shell
>redis keys key67*
  1) "key6764"
  2) "key6738"
  3) "key6774"
  4) "key673"
  5) "key6710"
  6) "key6759"
  7) "key6715"
  8) "key6746"
  9) "key6796"
```

- 没有 offset、limit 参数，一次性吐出所有满足条件的 key，万一实例中有几百 w 个 key 满足条件，

  当你看到满屏的字符串刷的没有尽头时，你就知道难受了。

- keys 算法是遍历算法，复杂度是 O(n)，如果实例中有千万级以上的 key，这个指令就会导致 Redis 服务卡顿，

  所有读写 Redis 的其它的指令都会被延后甚至会超时报错，

  因为 Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。

- 建议生产环境屏蔽keys命令



## Scan

- 复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;

- 提供 limit 参数，可以控制每次返回结果的最大条数，limit 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;

- 同 keys 一样，它也提供模式匹配功能;

- 服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;

- 返回的结果可能会有重复，需要客户端去重复，这点非常重要;

- 遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;

- 单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零



```shell
127.0.0.1:6379> keys  *   #一共3个key
1) "s"
2) "w"
3) "bit"
127.0.0.1:6379> scan 0 match * count 1  #除了查询出的key，还会返回游标的下一个位置
1) "1"
2) 1) "w"
127.0.0.1:6379> scan 1 match * count 1 
1) "3"
2) 1) "s"
127.0.0.1:6379> scan 3 match * count 1  # 遍历结束
1) "0"
2) 1) "bit"

```







## 参考

http://jinguoxing.github.io/redis/2018/09/04/redis-scan/

