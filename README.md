# Redis学习

## 目录

- [基础数据结构](基础数据结构)
  - [summary](基础数据结构/summary.md)
  - [sds简单动态字符串][基础数据结构/sds简单动态字符串.md]
  - [linkedlist双端链表](基础数据结构/linkedlist双端链表.md)
  - [ziplist压缩列表](基础数据结构/ziplist压缩列表.md)
  - [quicklist快速链表](基础数据结构/quicklist快速链表.md)
  - [dict字典](基础数据结构/dict字典.md)
  - [inset整数集合](基础数据结构/inset整数集合.md)
  - [skiplist跳表](基础数据结构/skiplist跳表.md)


- [对象](/对象)
  - [redis对象](/对象/redis对象.md)
  - [字符串](/对象/string-字符串对象.md)
  - [列表](/对象/list-列表对象.md)
  - [哈希表](/对象/hash-哈希对象.md)
  - [集合对象](对象/set-集合对象.md)
  - [有序结合对象](/对象/zset-有序集合对象.md)
  - [拓展](/对象/拓展)
    - [布隆过滤器](/对象/拓展/布隆过滤器.md)
    - [大数据统计HyperLogLog](/对象/拓展/大数据统计HyperLogLog.md)
    - [二进制数组-位图](/对象/拓展/二进制数组-位图.md)
    - [Stream消息队列](/对象/拓展/Stream消息队列.md)
    - [地理位置GeoHash](/对象/拓展/地理位置GeoHash.md)

- [应用Application][Application]
	- [普通缓存](Application/普通缓存.md)
	- [分布式锁](Application/DistributedLock.md) 
	- [布隆过滤器](Application/布隆过滤器--推送新闻,网址黑名单,垃圾邮件.md)
  - [UV统计](Application/统一UV.md)
  - [排行榜](Application/排行榜.md)
  - [关注列表和粉丝列表](Application/关注列表和粉丝列表.md)
  - [广告弹窗触达频率的控制](Application/广告弹窗触达频率的控制.md)
  - [延时队列](Application/延时队列.md)




## 资料

-   [掘金小册-redis深度历险](https://juejin.im/book/5afc2e5f6fb9a07a9b362527/)

- 《Redis设计与实现》[网址阅读链接](http://redisbook.com/index.html)

- 《Redis实战》

- [张铁蕾的博客](https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=509777776&idx=1&sn=e56f24bdf2de7e25515fe9f25ef57557&mpshare=1&scene=1&srcid=1010HdkIxon3icsWNmTyecI6#rd)

- https://www.cnblogs.com/kismetv/p/9236731.html



## CAP理论

### Consistency 一致性

一致性指“`all nodes see the same data at the same time`”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，所以，一致性，说的就是数据一致性。

对于一致性，可以分为从客户端和服务端两个不同的视角。

从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。

从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。

**三种一致性策略**

对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。

如果能容忍后续的部分或者全部访问不到，则是弱一致性。

如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。

CAP中说，不可能同时满足的这个一致性指的是强一致性。

### Availability 可用性

可用性指“`Reads and writes always succeed`”，即服务一直可用，而且是正常响应时间。

对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。

|          可用性分类          | 可用水平（%） | 年可容忍停机时间 |
| :--------------------------: | :-----------: | :--------------: |
|          容错可用性          |    99.9999    |      <1 min      |
|          极高可用性          |    99.999     |      <5 min      |
| 具有故障自动恢复能力的可用性 |     99.99     |     <53 min      |
|           高可用性           |     99.9      |      <8.8h       |
|          商品可用性          |      99       |    <43.8 min     |

通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 `(1-0.99999)*365*24*60 = 5.256 min`，这是一个极高的要求。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。一个分布式系统，上下游设计很多系统如负载均衡、WEB服务器、应用代码、数据库服务器等，任何一个节点的不稳定都可以影响可用性。



### Partition Tolerance分区容错性

分区容错性指“`the system continues to operate despite arbitrary message loss or failure of part of the system`”，即分布式系统在遇到某节点或网络分区故障,丢包的时候，仍然能够对外提供满足一致性和可用性的服务。



### CAP权衡

#### CA without P

所以如果你的分布式系統做到 CA，牺牲`Partition Tolerance`，那就是代表你的机房永远不會出現网络分区，永遠不會丢包 ，这么完美的机房给我來一打吧…除非有可能有完美的网路环境，否則 CA 根本就是传统的单机系统，而非分布式系統。

在分布式环境下，网络分区是一个自然的事实。因为分区是必然的，所以如果舍弃P，意味着要舍弃分布式系统。



#### CP without A

如果一个分布式系统不要求强的可用性，即容许系统停机或者长时间无响应的话，就可以在CAP三者中保障CP而舍弃A。

一个保证了CP而一个舍弃了A的分布式系统，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。

在单机版的Redis中，每个Master之间是没有任何通信的，所以我们一般在Jedis客户端或者Codis这样的代理中做Pre-sharding。按照CAP理论来说，单机版的Redis属于保证CP(Consistency & Partition-Tolerancy)而牺牲A(Availability)，也就说Redis能够保证所有用户看到相同的数据（一致性，因为Redis不自动冗余数据）和网络通信出问题时，暂时隔离开的子系统能继续运行（分区容忍性，因为Master之间没有直接关系，不需要通信），但是不保证某些结点故障时，所有请求都能被响应（可用性，某个Master结点挂了的话，那么它上面分片的数据就无法访问了）。

 有了Cluster功能后，Redis从一个单纯的NoSQL内存数据库变成了分布式NoSQL数据库，CAP模型也从CP变成了AP。也就是说，通过自动分片和冗余数据，Redis具有了真正的分布式能力，某个结点挂了的话，因为数据在其他结点上有备份，所以其他结点顶上来就可以继续提供服务，保证了Availability。然而，也正因为这一点，Redis无法保证曾经的强一致性了。这也是CAP理论要求的，三者只能取其二。

#### AP wihtout C

要高可用并允许分区，则需放弃一致性。一旦网络问题发生，节点之间可能会失去联系。为了保证高可用，需要在用户访问时可以马上得到返回，则每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

这种舍弃强一致性而保证系统的分区容错性和可用性的场景和案例非常多。前面我们介绍可用性的时候说到过，很多系统在可用性方面会做很多事情来保证系统的全年可用性可以达到N个9，所以，对于很多业务系统来说，比如淘宝的购物，12306的买票。都是在可用性和一致性之间舍弃了一致性而选择可用性。

你在12306买票的时候肯定遇到过这种场景，当你购买的时候提示你是有票的（但是可能实际已经没票了），你也正常的去输入验证码，下单了。但是过了一会系统提示你下单失败，余票不足。这其实就是先在可用性方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，会影响一些用户体验，但是也不至于造成用户流程的严重阻塞。

但是，我们说很多网站牺牲了一致性，选择了可用性，这其实也不准确的。就比如上面的买票的例子，其实舍弃的只是强一致性。退而求其次保证了最终一致性。也就是说，虽然下单的瞬间，关于车票的库存可能存在数据不一致的情况，但是过了一段时间，还是要保证最终一致性的。

对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。



#### 参考

https://www.hollischuang.com/archives/666

[https://medium.com/@thegiive/cap-%E7%90%86%E8%AB%96-19cd81c82658](https://medium.com/@thegiive/cap-理論-19cd81c82658)





## 一致性

### 强一致性

当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

java的volatile是这样.



### 弱一致性

当更新操作完成之后，如果能容忍后续的部分或者全部访问不到，则是**弱一致性**



### 最终一致性

当更新操作完成之后，如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。



### **因果一致性**

如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。

#### 读己之所写（read-your-writes）一致性

当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。

### 单调一致性

- **单调（Monotonic）读一致性**

如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。

这基本不是问题

- **单调写一致性**

系统保证来自同一个进程的写操作顺序执行