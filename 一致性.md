## 强一致性

当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

java的volatile是这样.



## 弱一致性

当更新操作完成之后，如果能容忍后续的部分或者全部访问不到，则是**弱一致性**



## 最终一致性

当更新操作完成之后，如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。



###  **因果一致性**
如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。



### 读己之所写（read-your-writes）一致性

*当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。*




### 单调一致性

#### **单调（Monotonic）读一致性**

*如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。*

这基本不是问题

#### **单调写一致性**

系统保证来自同一个进程的写操作顺序执行