# 布隆过滤器

## 介绍

**mightContains**  

判断某个值存在时，这个值可能不存在；判断不存在时，那就肯定不存在。

**不支持删除**

一个bit位置其实是被复用的.

**不可逆,无法迁移扩容**



## 基本使用

布隆过滤器有二个基本指令，`bf.add` 添加元素，`bf.exists` 查询元素是否存在.

```shell
127.0.0.1:6379> bf.add codehole user1
(integer) 1
127.0.0.1:6379> bf.add codehole user2
(integer) 1
127.0.0.1:6379> bf.add codehole user3
(integer) 1
127.0.0.1:6379> bf.exists codehole user1
(integer) 1
127.0.0.1:6379> bf.exists codehole user2
(integer) 1
127.0.0.1:6379> bf.exists codehole user3
(integer) 1
127.0.0.1:6379> bf.exists codehole user4
(integer) 0
127.0.0.1:6379> bf.madd codehole user4 user5 user6
1) (integer) 1
2) (integer) 1
3) (integer) 1
127.0.0.1:6379> bf.mexists codehole user4 user5 user6 user7
1) (integer) 1
2) (integer) 1
3) (integer) 1
4) (integer) 0
```

## 配置

`bf.reserve`有三个参数，分别是 key, `error_rate`和`initial_size`。

注意,在给定错误率下,当实际元素大大超出预计元素时,错误率会显著上升.



## 场景

### 如果在就不去做xxxxx,接受一定误差

#### 新闻端去重

我们在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要去重，去掉那些已经看过的内容。

可以使用布隆过滤器,当然,可能产生误判,本来没推送过,但是K个hash后却判定存在,但可完全可以接受,因为不推送就不推送了,可以推送其他的.



#### 网址黑名单屏蔽

如果布隆过滤器判定存在,也就是在黑名单中,就禁止访问.当然这样会产生误差



#### URL去重

实现接受一定误差的快速去重





### 如果不在就不用做了,这种没误差

#### 大批量无效查询

比如我总是要根据id去查询商品信息,但是我提供的商品查询接口,使用方太多,经常输入无效的id.造成压力.

这种情况下,先将商品分类,然后初始化布隆过滤器,使用类别+id填充.

在查询时候,先用布隆过滤器判断在不在,如果不在就没必要查了.直接返回失败.



## 扩容

因为布隆过滤器的不可逆，我们没法重新建一个更大的布隆过滤器然后去把数据重新导入。这边采取的扩容的方法是，保留原有的布隆过滤器，建立一个更大的，新增数据都放在新的布隆过滤器中，去重的时候检查所有的布隆过滤器。



## 时效,过期删除

使用布隆过滤器对url去重，但是每五个月要重新爬取一次。这边介绍一种循环的布隆过滤器，类似于之前的思路，由多个布隆过滤器组成，每个月都清空最早的那个过滤器。

start代表存放最早数据的指针

```
1       2      3      4      5
start  end         

1       2      3      4      5
start         end   

1       2      3      4      5
start                end   

1       2      3      4      5
start                       end  

1       2      3      4      5
end   start                      

```





