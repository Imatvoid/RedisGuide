# DistributedLock
> 分布式锁

## 工具和资源
```
# 5参数set命令 附加参数可以设置过期时间 和NX XX
SET key value EX(秒)|PX（毫秒） max-lock-time  NX(不存在则设置)|XX（存在则设置）

# get+del  使用lua脚本实现命令原子性。


```
## tip

1.先set（老）/setNx，然后 expire,没有原子性,若设置set/setNx后异常，未执行expire会导致永不过期。

2.lock时候set的value应该是每个客户端唯一的,比如客户端唯一id+currentTime,这样在unlock时候,使用lua脚本实现"delIfEqual",只会释放自己的锁,不会误释放。





## 存在的问题

### 业务超时

得到锁后,由于业务执行时间过长,导致的超时过期释放锁的问题,redis实现的分布式锁无法解决,如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决,或者需考虑其他方案。

### 集群主从同步问题

**场景**

一个客户端从集群主节点申请了一把分布式锁之后,主节点挂掉,锁的数据还没来得及同步到从节点,然后某个从节点取而代之成为主节点.客户端无感知.

另一个客户端又过来请求加锁,也成功了.

这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。

不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，而且持续时间极短，业务系统多数情况下可以容忍。

**Redlock算法**

如果你很在乎正确性，希望挂了一台 redis 完全不受影响，那就应该考虑 redlock。不过代价也是有的，需要更多的 redis 实例，性能也下降了，代码上还需要引入额外的 library，运维上也需要特殊对待，这些都是需要考虑的成本，使用前请再三斟酌。

**算法概述**

在Redis的分布式环境中，我们假设有N个Redis master。这些节点**完全互相独立，不存在主从复制或者其他集群协调机制**。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。

为了取到锁，客户端应该执行以下操作:

- 获取当前Unix时间，以毫秒为单位。
- 依次尝试从5个实例，使用相同的key和**具有唯一性的value**（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。
- 客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。**当且仅当从大多数**（N/2+1，这里是3个节点）**的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功**。
- 如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
- 如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在**所有的Redis实例上进行解锁**（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。



并非绝对安全,比如系统时间不同步:

用不可靠的时钟打破 Redlock.

这节 Martin 举了个因为时间问题，Redlock 不可靠的例子。

1. client1 从 ABC 三个节点处申请到锁，DE由于网络原因请求没有到达
2. C节点的时钟往前推了，导致 lock 过期
3. client2 在CDE处获得了锁，AB由于网络原因请求未到达
4. 此时 client1 和 client2 都获得了锁

http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html

https://juejin.im/post/59f592c65188255f5c5142d2




















