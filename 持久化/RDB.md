# RDB持久化

> 全量备份,内存数据的二进制序列化

## 命令

```SHELL
> SAVE  # 直到RDB文件创建完毕
ok

> BGSAVE # 开启子进程创建RDB文件，服务器进程（父进程）继续处理命令请求
Background saving started
```

### SAVE

阻塞服务器进程



### BGSAVE

子进程

```python
pid = os.fork()
if pid > 0:
    handle_client_requests()  # 父进程继续处理客户端请求
if pid == 0:
    handle_snapshot_write()  # 子进程处理快照写磁盘
if pid < 0:
    # fork error
```

 从fork开始分支(称分支不准确) 一路是主进程   pid> 0 (pid 是子进程ID),一路是子进程   pid   ==   0   自此分成两个任务 
数据段被复制了一份.

## 快照的含义

SAVE命令产生"快照"十分好理解，因为一旦执行，内存里的数据在一瞬间就凝固了，不会改变，可以非常安心的遍历数据了进行序列化写磁盘

对于BGSAVE来说情况有些许不同.

子进程做数据持久化，它不会修改现有的内存数据结构，它只是对数据结构进行遍历读取，然后序列化写到磁盘中。但是父进程不一样，它必须持续服务客户端请求，然后对内存数据结构进行不间断的修改。



这个时候就会使用操作系统的 COW 机制来进行数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。



随着父进程修改操作的持续进行，越来越多的共享页面被分离出来，内存就会持续增长。但是也不会超过原有数据内存的 2 倍大小。另外一个 Redis 实例里冷数据占的比例往往是比较高的，所以很少会出现所有的页面都会被分离，被分离的往往只有其中一部分页面。每个页面的大小只有 4K，一个 Redis 实例里面一般都会有成千上万的页面。

子进程因为数据没有变化，它能看到的内存里的数据在进程产生的一瞬间就凝固了，再也不会改变。子进程也可以安心序列化数据到磁盘。